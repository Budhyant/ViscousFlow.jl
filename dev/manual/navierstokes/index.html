<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Navier-Stokes systems · ViscousFlow.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ViscousFlow.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../fields/">Fields</a></li><li><a class="toctext" href="../bodies/">Bodies</a></li><li><a class="toctext" href="../saddlesystems/">Saddle point systems</a></li><li><a class="toctext" href="../timemarching/">Time marching</a></li><li class="current"><a class="toctext" href>Navier-Stokes systems</a><ul class="internal"><li><a class="toctext" href="#Navier-Stokes-without-a-body-1">Navier-Stokes without a body</a></li><li><a class="toctext" href="#Methods-1">Methods</a></li><li><a class="toctext" href="#Index-1">Index</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Navier-Stokes systems</a></li></ul><a class="edit-page" href="https://github.com/jdeldre/ViscousFlow.jl/blob/master/docs/src/manual/navierstokes.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Navier-Stokes systems</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Navier-Stokes-systems-1" href="#Navier-Stokes-systems-1">Navier-Stokes systems</a></h1><div>\[\def\ddt#1{\frac{\mathrm{d}#1}{\mathrm{d}t}}

\renewcommand{\vec}{\boldsymbol}
\newcommand{\uvec}[1]{\vec{\hat{#1}}}
\newcommand{\utangent}{\uvec{\tau}}
\newcommand{\unormal}{\uvec{n}}

\renewcommand{\d}{\,\mathrm{d}}\]</div><div></div><p>Here, we will focus on putting tools together from the previous sections in order to set up and solve the Navier-Stokes system of equations. First, we will solve them in a completely unbounded domain (i.e., no bodies), and then we will solve them in the vicinity of a body.</p><h2><a class="nav-anchor" id="Navier-Stokes-without-a-body-1" href="#Navier-Stokes-without-a-body-1">Navier-Stokes without a body</a></h2><p>Here, we seek the solve the two-dimensional incompressible Navier-Stokes equations in their <em>discrete vorticity form</em>, in an unbounded domain:</p><div>\[\ddt w + N(v,w) = \frac{1}{Re} L w,\]</div><p>along with the initial condition</p><div>\[w(0) = w_0.\]</div><p>The field <span>$w$</span> represents the discrete vorticity, which sits at the nodes of the dual cells. The velocity, <span>$v$</span>, lies on the edges of the primal cells. They are related to each other by <span>$v = Cs$</span>, where <span>$s = -L^{-1} w$</span> is the discrete streamfunction.</p><p>The second term on the left-hand side is the convective term, which we have simply written as <span>$N(v,w)$</span>. There are several ways to write this term; here, we will write it by using the discrete divergence,</p><div>\[N(v,w) = D(vw).\]</div><p>The <code>Systems</code> module has a function that is set up to compute this term; we will discuss it below. The right-hand side contains the viscous term, proportional to <span>$1/Re$</span>, where <span>$Re$</span> is the Reynolds number. For this, we will use the integrating factor, described in <a href="../fields/#The-integrating-factor-1">The integrating factor</a>. For purposes of calculation, it is better to express the problem as</p><div>\[\ddt w - \frac{1}{Re} L w = r_1(w),\]</div><p>where <span>$r_1(w) = -D(vw)$</span>.</p><p>For demonstration, we will solve a problem consisting initially of two identical circular patches of vorticity.</p><div></div><p>The first thing we must do is set up a grid. We will make it square, with spacing equal to 0.02 in each cell.</p><pre><code class="language-julia-repl">julia&gt; xlim = (-2,2); ylim = (-2,2);

julia&gt; Δx = 0.02;</code></pre><p>Now we will set the Reynolds number, and set the time step size so that it follows the so-called <em>CFL</em> condition (with CFL number set to 0.5). To be careful, we also make sure the time step size does not exceed a threshold in the grid Fourier number (also set to 0.5):</p><pre><code class="language-julia-repl">julia&gt; Re = 200
200

julia&gt; Δt = min(0.5*Δx,0.5*Δx^2*Re)
0.01</code></pre><p>Now we set up the Navier-Stokes system. This sets the rest of the grid parameters, (number of cells, etc), and creates some some buffer space on the grid.</p><pre><code class="language-julia-repl">julia&gt; sys = NavierStokes(Re,Δx,xlim,ylim,Δt)
Navier-Stokes system on a grid of size 202 x 202</code></pre><p>For example, to check how many dual grid cells we have, we can use the <code>size</code> function, which has been extended to such systems:</p><pre><code class="language-julia-repl">julia&gt; size(sys)
(202, 202)</code></pre><p>Let&#39;s set up a set of dual nodes on this grid:</p><pre><code class="language-julia-repl">julia&gt; w₀ = Nodes(Dual,size(sys));</code></pre><p>The physical grid coordinates of these dual nodes can be generated with the <code>coordinates</code> function:</p><pre><code class="language-julia-repl">julia&gt; xg, yg = coordinates(w₀,dx=sys.Δx,I0=Systems.origin(sys))
(-2.0100000000000002:0.02:2.0100000000000002, -2.0100000000000002:0.02:2.0100000000000002)</code></pre><p>Now we are ready to set up the integrator for this problem. To account for the viscous diffusion, we need the integrating factor. There are no body constraints to enforce, so we will use the integrating factor Runge-Kutta method (<code>IFRK</code>). For this, we need to set up plans for the integrating factor and for the right-hand side (<span>$r_1$</span>). The <code>Systems</code> module has functions that do both for us, using the system data in <code>sys</code>. We just need to change their argument list so that they fit the template for the <code>IFRK</code> scheme:</p><pre><code class="language-julia-repl">julia&gt; plan_intfact(t,w) = Systems.plan_intfact(t,w,sys)
plan_intfact (generic function with 1 method)

julia&gt; r₁(w,t) = Systems.r₁(w,t,sys)
r₁ (generic function with 1 method)</code></pre><p>Now we can construct the integrator. We will use 3rd-order Runge-Kutta:</p><pre><code class="language-julia-repl">julia&gt; ifrk = IFRK(w₀,sys.Δt,plan_intfact,r₁,rk=TimeMarching.RK31)
Order-3 IF-RK integator with
   State of type Nodes{Dual,202,202}
   Time step size 0.01</code></pre><p>Note that we have only passed in <code>w₀</code> to this scheme to provide the form of data to be used for the state vector in the integrator. It does not matter that the data are still zeros.</p><p>Finally we are ready to solve the problem. We set up the initial condition. It is helpful to define a function first that specifies the vorticity distribution in each vortex patch. We will use a Gaussian:</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra

julia&gt; gaussian(x,x0,σ) = exp(-LinearAlgebra.norm(x.-x0)^2/σ^2)/(π*σ^2)
gaussian (generic function with 1 method)</code></pre><p>Now the initial conditions. We will put one vortex at <span>$(-0.5,0)$</span> and the other at <span>$(0.5,0)$</span>. They will each have a strength of <span>$1$</span> and a radius of <span>$0.2$</span>:</p><pre><code class="language-julia-repl">julia&gt; t = 0.0
0.0

julia&gt; x01 = (-0.5,0); x02 = (0.5,0); σ = 0.2; Γ = 1
1

julia&gt; w₀ .= [Γ*gaussian((x,y),x01,σ) + Γ*gaussian((x,y),x02,σ) for x in xg, y in yg]*Δx;

julia&gt; w = deepcopy(w₀);</code></pre><p>Note that we have multiplied the vorticity vector by the grid spacing. This is because the vector <code>w</code> is not actually the vorticity, but rather, a <em>grid</em> vorticity related to velocity through differencing. Let&#39;s plot it to see what we are starting with:</p><pre><code class="language-julia-repl">julia&gt; plot(xg,yg,w)
Plot{Plots.PyPlotBackend() n=1}</code></pre><p><img src="../w0corotate.svg" alt/></p><p>We will integrate the problem for 1 time unit:</p><pre><code class="language-julia-repl">julia&gt; tf = 1
1

julia&gt; T = 0:Δt:tf
0.0:0.01:1.0</code></pre><p>Now, do it. We will time it to see how long it takes:</p><pre><code class="language-julia-repl">julia&gt; @time for ti in T
           global t, w = ifrk(t,w)
       end
  7.810021 seconds (12.54 k allocations: 879.148 MiB, 1.52% gc time)</code></pre><p>and plot it again:</p><pre><code class="language-julia-repl">julia&gt; plot(xg,yg,w)
Plot{Plots.PyPlotBackend() n=1}</code></pre><p><img src="../w1corotate.svg" alt/></p><p>Let&#39;s go further!</p><pre><code class="language-julia-repl">julia&gt; tf = 5
5

julia&gt; T = 0:Δt:tf
0.0:0.01:5.0

julia&gt; @time for ti in T
           global t, w = ifrk(t,w)
       end
 38.505641 seconds (43.60 k allocations: 4.258 GiB, 1.29% gc time)</code></pre><pre><code class="language-julia-repl">julia&gt; plot(xg,yg,w)
Plot{Plots.PyPlotBackend() n=1}</code></pre><p><img src="../w2corotate.svg" alt/></p><h2><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ViscousFlow.Systems.NavierStokes" href="#ViscousFlow.Systems.NavierStokes"><code>ViscousFlow.Systems.NavierStokes</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct NavierStokes{NX, NY, N, isstatic}</code></pre><p>A system type that utilizes a grid of <code>NX</code> x <code>NY</code> dual cells and <code>N</code> Lagrange forcing points to solve the discrete Navier-Stokes equations in vorticity form. The parameter <code>isstatic</code> specifies whether the forcing points remain static in the grid.</p><p><strong>Fields</strong></p><ul><li><code>Re</code>: Reynolds number</li><li><code>U∞</code>: Tuple of components of free-stream velocity</li><li><code>Δx</code>: Size of each side of a grid cell</li><li><code>I0</code>: Tuple of indices of the primal node corresponding to physical origin</li><li><code>Δt</code>: Time step</li><li><code>rk</code>: Runge-Kutta coefficients</li><li><code>L</code>: Pre-planned discrete Laplacian operator and inverse</li><li><code>X̃</code>: Lagrange point coordinate data (if present), expressed in inertial coordinates       (if static) or in body-fixed coordinates (if moving)</li><li><code>Hmat</code>: Pre-computed regularization matrix (if present)</li><li><code>Emat</code>: Pre-computed interpolation matrix (if present)</li><li><code>Vb</code>: Buffer space for vector data on Lagrange points</li><li><code>Fq</code>: Buffer space for primal cell edge data</li><li><code>Ww</code>: Buffer space for dual cell edge data</li><li><code>Qq</code>: More buffer space for dual cell edge data</li><li><code>_isstore</code>: flag to specify whether to store regularization/interpolation matrices</li></ul><p><strong>Constructors:</strong></p><p><code>NavierStokes(Re,Δx,xlimits,ylimits,Δt               [,U∞ = (0.0, 0.0)][,X̃ = VectorData{0}()]               [,isstore=false][,isstatic=true]               [,rk=TimeMarching.RK31])</code> specifies the Reynolds number <code>Re</code>, the grid               spacing <code>Δx</code>, the dimensions of the domain in the tuples <code>xlimits</code>               and <code>ylimits</code> (excluding the ghost cells), and the time step size <code>Δt</code>.               The other arguments are optional. Note that <code>isstore</code> set to <code>true</code>               would store matrix versions of the operators. This makes the method               faster, at the cost of storage.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jdeldre/ViscousFlow.jl/blob/148772e83601dd217b1fb98cdba705332679d2b1/src/systems/navier_stokes.jl#L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ViscousFlow.Systems.PointForce-Tuple{Tuple{Float64,Float64},Float64,Float64,Float64,NavierStokes}" href="#ViscousFlow.Systems.PointForce-Tuple{Tuple{Float64,Float64},Float64,Float64,Float64,NavierStokes}"><code>ViscousFlow.Systems.PointForce</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">PointForce(x0::Tuple{Float64,Float64},f0,t0,σ,sys::NavierStokes)</code></pre><p>Constructor function that immerses a point force in the dual nodes of system <code>sys</code>, of strength <code>f0</code> to be applied at physical position <code>x0</code>, modulated by a Gaussian centered at time <code>t0</code> with standard deviation <code>σ</code>.</p><p>The resulting function is a function of time and generates a field on dual nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jdeldre/ViscousFlow.jl/blob/148772e83601dd217b1fb98cdba705332679d2b1/src/systems/navierstokes/systemutils.jl#L12-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ViscousFlow.Systems.origin-Tuple{NavierStokes}" href="#ViscousFlow.Systems.origin-Tuple{NavierStokes}"><code>ViscousFlow.Systems.origin</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">origin(sys::NavierStokes) -&gt; Tuple{Int,Int}</code></pre><p>Return a tuple of the indices of the primal node that corresponds to the physical origin of the coordinate system used by <code>sys</code>. Note that these indices need not lie inside the range of indices occupied by the grid. For example, if the range of physical coordinates occupied by the grid is (1.0,3.0) x (2.0,4.0), then the origin is not inside the grid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jdeldre/ViscousFlow.jl/blob/148772e83601dd217b1fb98cdba705332679d2b1/src/systems/navier_stokes.jl#L153-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.size-Union{Tuple{NY}, Tuple{NX}, Tuple{NavierStokes{NX,NY,N,isstatic} where isstatic where N,Int64}} where NY where NX" href="#Base.size-Union{Tuple{NY}, Tuple{NX}, Tuple{NavierStokes{NX,NY,N,isstatic} where isstatic where N,Int64}} where NY where NX"><code>Base.size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">size(sys::NavierStokes,d::Int) -&gt; Int</code></pre><p>Return the number of indices of the grid used by <code>sys</code> along dimension <code>d</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jdeldre/ViscousFlow.jl/blob/148772e83601dd217b1fb98cdba705332679d2b1/src/systems/navier_stokes.jl#L139-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.size-Union{Tuple{NavierStokes{NX,NY,N,isstatic} where isstatic where N}, Tuple{NY}, Tuple{NX}} where NY where NX" href="#Base.size-Union{Tuple{NavierStokes{NX,NY,N,isstatic} where isstatic where N}, Tuple{NY}, Tuple{NX}} where NY where NX"><code>Base.size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">size(sys::NavierStokes) -&gt; Tuple{Int,Int}</code></pre><p>Return a tuple of the number of indices of the grid used by <code>sys</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/jdeldre/ViscousFlow.jl/blob/148772e83601dd217b1fb98cdba705332679d2b1/src/systems/navier_stokes.jl#L146-L150">source</a></section><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="#ViscousFlow.Systems.NavierStokes"><code>ViscousFlow.Systems.NavierStokes</code></a></li><li><a href="#ViscousFlow.Systems.PointForce-Tuple{Tuple{Float64,Float64},Float64,Float64,Float64,NavierStokes}"><code>ViscousFlow.Systems.PointForce</code></a></li><li><a href="#Base.size-Union{Tuple{NavierStokes{NX,NY,N,isstatic} where isstatic where N}, Tuple{NY}, Tuple{NX}} where NY where NX"><code>Base.size</code></a></li><li><a href="#Base.size-Union{Tuple{NY}, Tuple{NX}, Tuple{NavierStokes{NX,NY,N,isstatic} where isstatic where N,Int64}} where NY where NX"><code>Base.size</code></a></li><li><a href="#ViscousFlow.Systems.origin-Tuple{NavierStokes}"><code>ViscousFlow.Systems.origin</code></a></li></ul><footer><hr/><a class="previous" href="../timemarching/"><span class="direction">Previous</span><span class="title">Time marching</span></a></footer></article></body></html>
